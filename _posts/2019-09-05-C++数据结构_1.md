---
title: 数据结构
categories: 程序设计
date: 2019-09-05 12:23:00
---
# 10月30日代码
   - 实验课代码，画流程图。

```c
#include "stdio.h"
#include "string.h"
#include "stdlib.h"
 
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
 
#define MAXSIZE 40 /* 存储空间初始分配量 */
 
typedef int Status;	/* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef char String[MAXSIZE+1]; /* 0号单元存放串的长度 */
 
/* 输出字符串T */
void StrPrint(String T)
{
int i;
for(i=1;i<=T[0];i++)
printf("%c",T[i]);
printf("\n");
}
 
/* 若S为空串,则返回TRUE,否则返回FALSE */
Status StrEmpty(String S)
{
if(S[0]==0)
return TRUE;
else
return FALSE;
}
 
/* 生成一个其值等于chars的串T */
Status StrAssign(String T,char *chars)
{
int i;
if(strlen(chars)>MAXSIZE)
return ERROR;
else
{
T[0]=strlen(chars);
for(i=1;i<=T[0];i++)
T[i]=*(chars+i-1);
return OK;
}
}
 
/* 返回串的元素个数 */
int StrLength(String S)
{
return S[0];
}
 
/* 初始条件: 串S和T存在 */
/* 操作结果: 若S>T,则返回值>0;若S=T,则返回值=0;若S < T,则返回值< 0 */
int StrCompare(String S,String T)
{
int i;
for(i=1;i<=S[0]&&i<=T[0];++i)
if(S[i]!=T[i])
return S[i]-T[i];
return S[0]-T[0];
}
 
/* 用T返回S1和S2联接而成的新串。若未截断，则返回TRUE，否则FALSE */
Status Concat(String T,String S1,String S2)
{
int i;
if(S1[0]+S2[0]<=MAXSIZE)
{ /* 未截断 */
for(i=1;i<=S1[0];i++)
T[i]=S1[i];
for(i=1;i<=S2[0];i++)
T[S1[0]+i]=S2[i];
T[0]=S1[0]+S2[0];
return TRUE;
}
else
{ /* 截断S2 */
for(i=1;i<=S1[0];i++)
T[i]=S1[i];
for(i=1;i<=MAXSIZE-S1[0];i++)
T[S1[0]+i]=S2[i];
T[0]=MAXSIZE;
return FALSE;
}
}
 
/* 用Sub返回串S的第pos个字符起长度为len的子串。 */
Status SubString(String Sub,String S,int pos,int len)
{
int i;
if(pos < 1||pos>S[0]||len < 0||len>S[0]-pos+1)
return ERROR;
for(i=1;i<=len;i++)
Sub[i]=S[pos+i-1];
Sub[0]=len;
return OK;
}
 
/* 返回子串T在主串S中第pos个字符之后的位置。若不存在,则函数返回值为0。 */
/* 其中,T非空,1≤pos≤StrLength(S)。 */
int Index(String S, String T, int pos)
{
int i = pos;	/* i用于主串S中当前位置下标值，若pos不为1，则从pos位置开始匹配 */
int j = 1;	/* j用于子串T中当前位置下标值 */
while (i <= S[0] && j <= T[0]) /* 若i小于S的长度并且j小于T的长度时，循环继续 */
{
if (S[i] == T[j]) /* 两字母相等则继续 */
{
++i;
++j;
}
else /* 指针后退重新开始匹配 */
{
i = i-j+2;	/* i退回到上次匹配首位的下一位 */
j = 1; /* j退回到子串T的首位 */
}
}
if (j > T[0])
return i-T[0];
else
return 0;
}
 
/* 初始条件: 串S和T存在,1≤pos≤StrLength(S)+1 */
/* 操作结果: 在串S的第pos个字符之前插入串T。完全插入返回TRUE,部分插入返回FALSE */
Status StrInsert(String S,int pos,String T)
{
int i;
if(pos< 1||pos>S[0]+1)
return ERROR;
if(S[0]+T[0]<=MAXSIZE)
{ /* 完全插入 */
for(i=S[0];i>=pos;i--)
S[i+T[0]]=S[i];
for(i=pos;i < pos+T[0];i++)
S[i]=T[i-pos+1];
S[0]=S[0]+T[0];
return TRUE;
}
else
{ /* 部分插入 */
for(i=MAXSIZE;i<=pos;i--)
S[i]=S[i-T[0]];
for(i=pos;i < pos+T[0];i++)
S[i]=T[i-pos+1];
S[0]=MAXSIZE;
return FALSE;
}
}
 
/* 初始条件: 串S存在,1≤pos≤StrLength(S)-len+1 */
/* 操作结果: 从串S中删除第pos个字符起长度为len的子串 */
Status StrDelete(String S,int pos,int len)
{
int i;
if(pos < 1||pos>S[0]-len+1||len < 0)
return ERROR;
for(i=pos+len;i<=S[0];i++)
S[i-len]=S[i];
S[0]-=len;
return OK;
}
 
/* 初始条件: 串S,T和V存在,T是非空串（此函数与串的存储结构无关） */
/* 操作结果: 用V替换主串S中出现的所有与T相等的不重叠的子串 */
Status Replace(String S,String T,String V)
{
int i=1; /* 从串S的第一个字符起查找串T */
if(StrEmpty(T)) /* T是空串 */
return ERROR;
do
{
i=Index(S,T,i); /* 结果i为从上一个i之后找到的子串T的位置 */
if(i) /* 串S中存在串T */
{
StrDelete(S,i,StrLength(T)); /* 删除该串T */
StrInsert(S,i,V); /* 在原串T的位置插入串V */
i+=StrLength(V); /* 在插入的串V后面继续查找串T */
}
}while(i);
return OK;
}
 
int main()
{
int i, j, opp, pos;
char s, str;
String t,s1,s2,sub;
Status k;
 
printf("\n1.StrAssign 生成串 \n2.StrLength 求串长 \n3.StrCompare 串比较 ");
printf("\n4.Concat 串连接 \n5.SubString 求子串 \n6.Index 求子串位置");
printf("\n7.StrInsert 子串插入 \n8.StrDelete 子串删除 \n9.Replace 子串替换");
printf("\n0.退出 \n请选择你的操作：\n");
while(opp != '0')
{
scanf("%d",&opp);
switch(opp)
{
case 1:
k=StrAssign(s1,"hezhouxueyuanxinxixueyuan");
if(!k)
{
printf("串长超过MAXSIZE(=%d)\n",MAXSIZE);
exit(0);
}
printf("串s1为：");
StrPrint(s1);
printf("\n");
break;
 
case 2:
printf("串s1长为%d \n",StrLength(s1));
break;
 
case 3:
k=StrAssign(s2,"google.com");
if(!k)
{
printf("串长超过MAXSIZE(%d)\n",MAXSIZE);
exit(0);
}
printf("串s2为：");
StrPrint(s2);
printf("\n");
 
i=StrCompare(s1,s2);
if(i < 0)
s=' < ';
else if(i==0)
s='=';
else
s='>';
printf("串s1%c串s2\n",s);
break;
 
case 4:
Concat(t,s1,s2);
StrPrint(t);
break;
 
case 5:
printf("求串s1的子串,请输入子串的起始位置: ");
scanf("%d", &i);
printf("请输入子串的长度: ");
scanf("%d", &j);
printf("起始位置：%d，子串长度：%d\n", i, j);
k=SubString(sub,s1,i,j);
if(k)
{
printf("子串sub为: ");
StrPrint(sub);
}
break;
 
case 6:
printf("主串s1为: ");
StrPrint(s1);
k=StrAssign(sub,"magic");
printf("子串sub为: ");
StrPrint(sub);
i=Index(s1,sub,1);
printf("s1的第%d个字母起和sub第一次匹配\n",i);
break;
 
case 7:
printf("主串s1为: ");
StrPrint(s1);
k=StrAssign(sub,"lol");
printf("子串sub为: ");
StrPrint(sub);
printf("请输入要插入的位置: ");
scanf("%d", &pos);
StrInsert(s1,pos,sub);
StrPrint(s1);
break;
 
case 8:
printf("从串s1的第pos个字符起,删除len个字符，请输入pos: \n");
scanf("%d", &i);
printf("再输入len: \n");
scanf("%d", &j);
StrDelete(s1,i,j);
StrPrint(s1);
break;
 
case 9:
printf("主串s1为: ");
StrPrint(s1);
StrAssign(t,"a");
printf("串t为：");
StrPrint(t);
StrAssign(sub,"aa");
printf("串sub为：");
StrPrint(sub);
printf("用串s2取代串s1中和串t相同的不重叠的串后,串s1为: ");
Replace(s1,t,sub);
StrPrint(s1);
break;
 
case 0:
exit(0);
}
}
}


```

# 10月27日代码
   - 某陆的实验作业，加密解密

```cpp
#include <stdio.h>        //头文件 
#include <string.h>       // strlen()函数的头文件 

#define MAXSIZE 50       //定义最大容量 
typedef struct{          //串的结构定义 
	char ch[MAXSIZE+1];  //串的数据，包含结束符"\0" 
	int length;          //串的长度 
}SString;                //结构体类型标识符 

int StrAssign(SString &s,char *c){    //串的赋值 
	int i;                            
	if(strlen(c)>=MAXSIZE)            //判断是否超过最大容量 
		return 0;
	else{
		s.length=strlen(c);           //串S长度等于字符串c的长度 
		for(i=0;i<=s.length;i++)      //循环赋值 
			s.ch[i]=c[i];
		return 1;
	}
}

int StrTo(SString &s,SString &t,SString &pwd_1,SString &pwd_2,char *box){ //密码转译,相对应pwd_1→pwd_2, 
	int i,j;                            
	t.length=s.length;           
	for(i=0;i<=s.length;i++){
		for(j=0;s.ch[i]!=pwd_1.ch[j];j++){
			t.ch[i]=pwd_2.ch[j+1];	
		}
	}      
}

void str_out(SString s){              //串的输出 
	int i;
	for(i=0;i<s.length;i++)           //循环输出 
		printf("%c",s.ch[i]);
	printf("\n"); 
}

int main(){
	SString s,t,l,m1,m2; //定义结构体 
	char pwd_1[MAXSIZE]="abcdefghijklmnopqrstuvwxyz",pwd_2[MAXSIZE]="ngzqtcobmuhelkpdawxfyivrsj"; //密文 
	char a[MAXSIZE]="encrypt",box[MAXSIZE]; //a为原始密码。
	StrAssign(m1,pwd_1);  //串的赋值 (密码表) 
	StrAssign(m2,pwd_2);
	printf("字母映射表为:\n"); 
	str_out(m1);
	str_out(m2);	
	StrAssign(s,a);    //赋值 (密码)
	printf("加密前："); 
	str_out(s);	
	StrTo(s,t,m1,m2,box); //加密 m1→m2 ，s转译后放入t 
	printf("加密后："); 
	str_out(t);
	StrTo(t,l,m2,m1,box); //加密 m2→m1 ，t转译后放入l  
	printf("解密后："); 
	str_out(l);
}

```

# 10月23日代码
   - 实验课内容，p81，定长顺序存储

```cpp
#include <stdio.h>        //头文件 
#include <string.h>

#define MAXSIZE 50       //定义最大容量 
typedef struct{          //串的结构定义 
	char ch[MAXSIZE+1];  //串的数据，包含结束符"\0" 
	int length;          //串的长度 
}SString;                //结构体类型标识符 

int StrAssign(SString &s,char *c){    //串的赋值 
	int i;                            
	if(strlen(c)>=MAXSIZE)            //判断是否超过最大容量 
		return 0;
	else{
		s.length=strlen(c);           //串S长度等于字符串c的长度 
		for(i=0;i<=s.length;i++)      //循环赋值 
			s.ch[i]=c[i];
		return 1;
	}
}

void str_out(SString s){              //串的输出 
	int i;
	for(i=0;i<s.length;i++)           //循环输出 
		printf("%c",s.ch[i]);
	printf("\n"); 
}

void str_insert(SString s,SString t,int pos){//串的插入，在串s的下标为pos的字符前插入串t 
	int i;
	if(pos<0||pos>s.length)                              //插入位置合法性判断 
		printf("错误");
	if(s.length+t.length<=MAXSIZE){                      //插入后的串长<MAXSIZE 
		for(i=s.length+t.length-1;i>=t.length+pos;i--)
			s.ch[i]=s.ch[i-t.length];
		for(i=0;i<t.length;i++)
			s.ch[i+pos]=t.ch[i];
		s.length=s.length+t.length;
	} 
	else if(pos+t.length<=MAXSIZE){             //插入后串长>MAXSIZE且pos+LC<=MAXSIZE 
		for(i=MAXSIZE-1;i>t.length+pos-1;i--)
			s.ch[i]=s.ch[i-t.length];
		for(i=0;i<t.length;i++)
			s.ch[i+pos]=t.ch[i];
		s.length=MAXSIZE;
	}
	else{                                     //插入后串长>MAXSIZE且pos+LC>MAXSIZE 
		for(i=0;i<MAXSIZE-pos;i++){
			s.ch[i+pos]=t.ch[i];
			s.length=MAXSIZE;
		}	
	}
	printf("将t插入到s后："); 
	str_out(s);
}

void str_delete(SString s,int pos,int len){   //串的删除，在串s中删除从下标pos开始的长度为len的字串 
	int i;
	if(pos<0||pos>s.length-len)            //删除合法性判断 
		printf("错误");
	for(i=pos+len;i<s.length;i++)          //将删除部分后面的串向前移动 
		s.ch[i-len]=s.ch[i];
	s.length=s.length-len;                 //串s长度-len 
	printf("删除后的串："); 
	str_out(s);
}

int str_compare(SString s,SString t){//对比串，负数s<t 整数s>t 0则相等 
	int i;	
	for(i=0;i<s.length&&i<t.length;i++)  //依次比较字符的ASCII码。 
		if(s.ch[i]!=t.ch[i]){
			return s.ch[i]-t.ch[i];
		}
	return s.length-t.length;
}

int main(){
	SString s,t; 
	char c1[MAXSIZE]="abcdef",c2[MAXSIZE]="123456";     //串的赋值 
	StrAssign(s,c1);
	StrAssign(t,c2);	
	printf("%d\n",str_compare(s,t));             //对比串 
	str_insert(s,t,3);           //串的插入 
	str_delete(s,3,2);           //串的删除 
	
}

```

# 10月10号代码
   - 实验课内容，编写栈的功能

```cpp
#include <stdio.h>
#define StackSize 100

typedef char DataType;
typedef struct{
	DataType data[StackSize];
	int top;
}SeqStack;
SeqStack *S;
void InitStack(SeqStack *S){
	S->top=-1;
}
int StackEmpty(SeqStack *S){
	return S->top==-1;
}
int StackFull(SeqStack *S){
	return S->top==StackSize-1;
}
int push(SeqStack *S,DataType x){
	if(StackFull(S)){
		puts("栈满");
		return 0; 
	}
	S->data[++S->top]=x;
	return 1;
}
DataType Pop(SeqStack *S){
	if(StackEmpty(S)){
		puts("栈空");
		return 0;
	}
	return S->data[S->top--];
}
DataType StackTop(SeqStack *S){
	if(StackEmpty(S)){
		puts("栈空");
		return 0;
	}
	return S->data[S->top];
}
void Display(SeqStack *S){
	int i=0;
	printf("\n栈的内容是：\n");
	printf("栈底 ");
	while(i<=S->top){
		printf("%d",S->data[i]);
		i++;
	}
	printf(" 栈顶");
	printf("\n");
}
int main(int argc,char *argv[]){
	SeqStack *S;
	int data,k;
	do{
		printf("\n1.建立空栈\n");
		printf("2.进栈\n");
		printf("3.出栈\n");
		printf("4.显示栈的内容\n");
		printf("5.判断是否为空栈\n");
		printf("6.判断是否为满栈\n");
		printf("7.获取栈顶元素\n");
		printf("8.退出\n");
		printf("请您选择：\n");
		scanf("%d",&k);
		switch(k){
			case 1:
				InitStack(S);
				break;
			case 2:
				printf("请输入入栈的数据(整型)：\n");
				scanf("%d",&data);
				if(push(S,data)) 
					printf("数据入栈成功！");
				break;
			case 3:
				data=Pop(S);
				printf("%d已出栈",data);
				break;
			case 4:
				Display(S);
				break;
			case 5:
				if(StackEmpty(S))
					printf("空栈！！");
				else	
					printf("非空栈！！");
				break; 
			case 6:
				if(StackEmpty(S))
					printf("满栈！！");
				else	
					printf("非满栈！！");
				break; 
			case 7:
				data=StackTop(S);
				printf("%d是栈顶元素",data);
				break;
			case 8:
				return 0;
		} 
	}
	while(k!=8);
	return 0;
} 
```

# 10月8号代码
   - 理论课作业，编写程序调试线性顺序表的所有功能函数

```cpp
#include <stdio.h>
#define MAX 100
typedef int DataType;
typedef struct{
    DataType Data[MAX];
    int length;
}SeqList;

void CreateList(SeqList &L){    //创建顺序表 
    int i=0,x;
    printf("请输入数据,结束于-1.\n");
    scanf("%d",&x);
    while(x!=-1){
        L.Data[i]=x;
        i++;
        scanf("%d",&x);
    }
    L.length=i;
}

void Out(SeqList L){    //输出
    int i;
    for(i=0;i<L.length;i++)
        printf("%d ",L.Data[i]);
    printf("\n"); 
}

int InsertList(SeqList &L){        //将t插入顺序表L 的第i个结点的位置上
    DataType t;
	int j,i;
	printf("插入数据t到第i个结点："); 
    scanf("%d%d",&t,&i);
    if (L.length>=MAX-1){
        printf("表满不能插入");
        return 0;
    }
    if (i<1||i>L.length+2){
        printf("插入位置错");
        return 0;
    }
    for(j=L.length;j>=i-1;j--){
        L.Data[j+1]=L.Data[j];//结点依次后移
    }
    L.Data[i-1]=t; //插入t
    L.length++; //表长+1
    return 1;
}

int DeleteList(SeqList &L,int i){  //删除指定结点的数据 
	printf("删除第%d个结点的数据\n",i); 
	int j;
	if(i<1||i>L.length+1){
		printf("不存在第%d个元素",i);
	 	return  0;
	}
	for(j=i;j<=L.length;j++)
		L.Data[j-1]=L.Data[j];
	L.length=L.length-1;
	return 1;
}

int LengthList(SeqList &L){  //顺序表长度 
	return L.length;
}

DataType GetList(SeqList &L,int i) {  //返回顺序表第i结点的值 
	return L.Data[i-1];
}

int SearchList(SeqList &L,DataType t){  //查找值,返回位置 
	int i=1 ;
	while(i<=L.length&&L.Data[i-1]!=t)
		i++;
	if(L.Data[i-1]==t)
		return i;
	else
		return -1;
	
}

void SortSeqList(SeqList &L)  {   //给数据从小到大排序，运用排序法 
    int i, j, tmp, max;  
    printf("将数据从小到大排序：");
    for(i = 0; i < L.length - 1; i++)  
    {  
        max = i;  
        for(j = i; j < L.length; j++)  
        {  
            if(L.Data[max] > L.Data[j])  
                max = j;  
        }  
        tmp = L.Data[i];  
        L.Data[i] = L.Data[max];  
        L.Data[max] = tmp;  
    }  
}    

main(){             //主程序
    SeqList L;
    CreateList(L);         
    printf("顺序表的长度为：%d\n",LengthList(L));
    InsertList(L);
    Out(L);
    DeleteList(L,2);
    Out(L);
    printf("第2个结点的数据为：%d\n",GetList(L,2));
	if(SearchList(L,5)!=-1)
    	printf("数据5所在位置：%d\n",SearchList(L,5));
    else
    	printf("数据5不存在");
    SortSeqList(L); 
    Out(L);
} 
  
```   

# 9月25号代码
   - 实验课代码，实现p45程序,有1个bug还没修复。

```c
# include <stdio.h> 
# include <malloc.h> 
# include <string.h>

typedef struct{
	char data[10];
	struct node *next;
}ListNode;

typedef ListNode *LinkList;

LinkList CreatList(void){
	char ch[100];
	LinkList head,p;
	head=(LinkList)malloc(sizeof(ListNode)); 
	head->next = NULL;
	while(1){
		printf("输入#结束\n");
		printf("请输入具体的职工名：");
		scanf("%s",&ch);
		if(strcmp(ch,"#")){
			if(LocateNode(head,ch)==NULL){
				strcpy(head->data,ch);
				p = (LinkList)malloc(sizeof(ListNode));
				p->next=head;
				head=p;
			}
		}
		else
			break;
	}
	return head;
}

int printlist(LinkList head){
	ListNode *p = head ->next;
	while(p){
		printf("%s,",p->data);
		p=p->next;
	}
	printf("\n");
} 

int DeleteList(LinkList head,char *key){
	ListNode *p,*r,*q=head;
	p=LocateNode(head,key);
	if(p==NULL){
		printf("position error");
		exit(0);
	}
	while(q->next!=p)
		q=q->next;
	r=q->next;
	q->next=r->next;
	free(r);
}

int LocateNode(LinkList head,char *key){
	int count = 0;
	ListNode *p = head ->next;
	while(p!=NULL&&strcmp(p->data,key)!=0){
		p=p->next;
		count++;
	}	
	return p;
	
	if(p==NULL){
		printf("没有查到该职工信息");
	}
	else{
		printf("%d",count);
		printf("找到该信息");
	}	
}

int main(){

	char ch[10],num[5];
	LinkList head;
	head = CreatList();
	

	printlist(head);
	

	printf("请输入要删除的信息");
	scanf("%s",ch);
	DeleteList(head,ch);
	printlist(head);
	
	printf("请输入要查找的信息");
	scanf("%s",ch);
	LocateNode(head,ch);

	printf("请输入要查找的信息");
	scanf("%s",ch);
	LocateNode(head,ch);
}

```

# 9月17号代码
   - 理论课代码，实现单链表部分功能。

```cpp
# include <stdio.h> 
# include <malloc.h> 

typedef int ElemType;
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LinkList;

LinkList *creat_1(){  //头插入法 
	LinkList *p,*L;
	int i=0;
	p=(LinkList *)malloc(sizeof(LinkList));    //创建头结点 
	//p->data = 100;   //赋值则开头即为开始结点。 
	p->next = NULL; //直接为NULL则有头文件 	
	while(i<4){
		L=(LinkList *)malloc(sizeof(LinkList));
		L->data = i*100+50;
		L->next=p->next;
		p->next=L; 
		i++;
	}
	return p;
}

LinkList *creat_2(){  //尾插入法 
	LinkList *p,*L,*q;
	int i=0;  
	p=(LinkList *)malloc(sizeof(LinkList));
	//p->data = 100;   //直接赋值则开头即为开始结点。 
	p->next = NULL; //直接为NULL则有头文件 	
	q=p;
	while(i<4){
		L=(LinkList *)malloc(sizeof(LinkList));
		L->data = i*100+50;
		L->next = NULL;
		q->next = L; //L.next=p.next;p.next=L； 
		q = L;
		i++;  
	}
	return p;
}

void out(LinkList *L){   //输出 
	LinkList *p;
	int i=0;	//定义变量计算个数 
	p=L->next;
	while(p!=NULL){
		printf("%d->",p->data);
		p=p->next;
		i++;	//个数统计累加 
	}
	printf("\n长度：%d\n",i);
}
int LocateElem(LinkList *L,ElemType e) {  //查找 
	int i=1;
	LinkList *p=L->next;
	while (p!=NULL && p->data!=e){
		p=p->next;
	 	
		i++;
	}
	if (p==NULL)
		return (0);
	else    
		return (1);
}        

main (){
	//头插入法演示 
	LinkList *L1 =creat_1();
	out(L1);
	//尾插入法演示 
	LinkList *L2 =creat_2();
	out(L2);
	//查找演示 
	printf("请输入你想查找的数:");
	int i;
	scanf("%d",&i);
	if(LocateElem(L1,i))
		printf("存在元素\n");
	else   
		printf("不存在元素\n");        
}

```

# 9月14号代码
   - 某陆的试验作业，求并集∪，但是我不按照某陆的要求写，只按照自己想法写。  

```cpp
#include <stdio.h>
#define MAXSIZE 6

typedef struct {
	int data[MAXSIZE];
	int length;
}SeqList;

int Lc[MAXSIZE];

void Union(SeqList &La, SeqList &Lb)//求并集
{
	int i, j;
	int num;
	int flag;
	int count = 0;
	for (i=0; i<4; i++){
		Lc[count++] = La.data[i];
	}
	num = count;
	for (i=0; i<3; i++){
		flag = 1;
		for (j=0; j<num; j++){
			if (Lc[j] == Lb.data[i]){
				flag = 0;
				break;
    		}
		}
		if (1 == flag){
			Lc[count++] = Lb.data[i];
		}
	}
}

void Output(){//输出
	int i;
	for (i=0; Lc[i]!=0; i++){
		printf("%d ", Lc[i]);
	}
	printf("\n");
}

int main(void){
	//直接初始化La和Lb 
	SeqList La={7,5,3,11};
	SeqList Lb={2,6,3};
	SeqList Lc;
	//求并集 
	Union(La,Lb);
	//输出 
	printf("A与B并集为:\n");
	Output();
}

```


# 9月11号代码  
   - 实验课代码，实现课本p38。

```cpp
#include <stdio.h>
#include <conio.h>
#include <windows.h>
#include <string.h>

#define MAX 100
typedef struct{ //定义学生结构体 
	char num[10];
	char name[20];
	int score;
}Student;

typedef struct{  //定义顺序表 
    Student Data[MAX];
    int last;
}SeqList;

void dispalyList(SeqList &L);
void dispalyOne(SeqList &L,int i);

SeqList createSeqList(){
	SeqList list;
	Student s;
	char num[10];
	list.last = -1;
	printf("请输入学生成绩，当学号为#时结束\n\n");
	while(1){
		printf("请输入学号：");
		scanf("%s",num);
		if(num[0]=='#')
			break;
		strcpy(s.num,num);
		printf("请输入姓名：");
		scanf("%s",&s.name);
		printf("请输入成绩：");
		scanf("%s",&s.score);
		list.last = list.last+1;
		list.Data[list.last]=s;
	}
	return list;
}

int InsertSeqList(SeqList &L,int i){        //将t插入顺序表L 的第i个结点的位置上
    int j,k,score;
    Student stu;
    if (L.last==MAX-1){
        printf("\n表满不能插入\n");
        return 0;
    }
    if (i<1||i>L.last+2){
        printf("\n插入位置错\n");
        return 0;
    }
    for(j=L.last;j>=i-1;j--){
        L.Data[j+1]=L.Data[j];//结点依次后移
    }
    L.Data[i-1]=stu; //插入t
    L.last++; //表长+1
    return 1;
}
int DeleteSeqList(SeqList &L,int i){  //删除指定学号的学生数据 
	int j;
	if(i<1||i>L.last+1){
		printf("不存在第%d个元素",i);
	 	return  0;
	}
	for(j=i;j<=L.last;j++)
		L.Data[j-1]=L.Data[j];
	L.last=L.last-1;
	return 1;
}

int LengthSeqList(SeqList &L){  //计算学生的总数 
	return L.last+1;
}

void LocateNum(SeqList &L,char num_find[]){   //按照学号查找学生 
	int i;
	for(i=0;i<=L.last;i++)
		if(strcmp(L.Data[i].num,num_find)==0){
			dispalyOne(L,i);
			break;
		}
} 

void LocateName(SeqList &L,char name_find[]){  //按姓名查找学生 
	int i;
	for(i=0;i<=L.last;i++)
		if(strcmp(L.Data[i].name,name_find)==0){
			dispalyOne(L,i);
			break;
		}
}

void dispalyList(SeqList &L){ //显示所有学生的成绩 
	int i=0,n;
	n=L.last;
	system("cls");
	printf("\n\n学号\t\t姓名\t\t成绩");
	while(i<=n){
		printf("\n%-6s\t\t",L.Data[i].num);
		printf("%-12s\t",L.Data[i].name);
		printf("%-4d",L.Data[i].score);
		i++;
	}
}

void dispalyOne(SeqList &L,int i){ //显示某个学生信息 
	printf("\n\n学号\t\t姓名\t\t成绩");
	printf("\n%-6s\t\t",L.Data[i].num);
	printf("%-12s\t",L.Data[i].name);
	printf("%-4d",L.Data[i].score);
}

void SortSeqList(SeqList &L){  //把学生成绩按从高到低的顺序排序 
	SeqList *L1 = (SeqList *)malloc(sizeof(SeqList));
	Student temp;
	int len,i,j;
	len=L.last;
	for(i=0;i<=len;i++){
		L1->Data[i]=L.Data[i];
	}
	L1->last = L.last;
	for(i=1;i<=len;i++){
		if(L1->Data[i].score>L1->Data[i-1].score){
			temp.score = L1->Data[i].score;
			strcpy(temp.num,L1->Data[i].num);
			strcpy(temp.name,L1->Data[i].name);
			L1->Data[i]=L1->Data[i-1];
			for(j=i-2;(temp.score>L1->Data[j].score)&&(j>=0);j--){
				L1->Data[j+1]=L1->Data[j];
			}
		L1->Data[j+1].score=temp.score;
		strcpy(L1->Data[j+1].num,temp.num);
		strcpy(L1->Data[j+1].name,temp.name);
		}
	}
}

int main(int argc,char *argv[]){             //主程序
    SeqList L;
    char temp[20],choose;
    int i,fz=1,res;
    printf("\n\n\n\n");
    printf("\t\t*******************************\n");
    printf("\t\t*******************************\n");
    printf("\t\t******学生成绩管理系统*********\n");
    printf("\t\t*******************************\n");
    printf("\t\t*******************************\n");
    getch();
    system("cls");
    while(fz){
    	printf("\n\n");
    	printf("\t\t1---创建链表\n");
    	printf("\t\t2---插入新同学信息\n");
    	printf("\t\t3---删除\n");
    	printf("\t\t4---总人数\n");
    	printf("\t\t5---按学号查找\n");
    	printf("\t\t6---按姓名查找\n");
    	printf("\t\t7---成绩排序\n");
    	printf("\t\t8---显示所有学生信息\n");
    	printf("\t\t9---退出\n");
    	choose=getch();
    	system("cls");
		switch(choose){
			case'1':
				L =createSeqList();
				dispalyList(L);
				getch();
				system("cls");
				break;
			case'2':
				printf("请输入插入位置："); 
				scanf("%d",&i);
				res = InsertSeqList(L,i);
				if(res==1)
					dispalyList(L);
				break;
			case'3':
				printf("请输入删除位置："); 
				scanf("%d",&i);
				res = DeleteSeqList(L,i);
				if(res==1)
					dispalyList(L);
				break;
			case'4':
				printf("学生总数为：%d\n",LengthSeqList(L)); 
				break;
			case'5':
				printf("请输入查找学生的学号："); 
				scanf("%s",&temp);
				printf("\n查找到的学生信息如下\n"); 
				LocateNum(L,temp);
				break;
			case'6':
				printf("请输入查找学生的姓名："); 
				scanf("%s",&temp);
				printf("\n查找到的学生信息如下\n"); 
				LocateName(L,temp);
				break;
			case'7':
				SortSeqList(L);
				dispalyList(L);
				break;
			case'8':
				dispalyList(L);
				break;
			case'9':
				printf("结束！\n");
				exit(0) ;
				break;
		}    	
    }
    system("PAUSE");
	return 0;
}
  

```


# 9月10号代码  
   - 理论课代码，实现输入，输入，插入功能。  

```cpp

#include <stdio.h>
#define MAX 100
typedef int DataType;
typedef struct{
    DataType Data[MAX];
    int length;
}SeqList;

void Create(SeqList &L){    //输入
    int i=0,x;
    printf(" input the data element,end with -1.\n");
    scanf("%d",&x);
    while(x!=-1){
        L.Data[i]=x;
        i++;
        scanf("%d",&x);
    }
    L.length=i;
}

void Out(SeqList L){    //输出
    int i;
    for(i=0;i<L.length;i++)
        printf("%d ",L.Data[i]);
}

int InsertList(SeqList &L,DataType t,int i){        //将t插入顺序表L 的第i个结点的位置上
    int j;
    if (L.length>=MAX-1){
        printf("表满不能插入");
        return 0;
    }
    if (i<1||i>L.length+2){
        printf("插入位置错");
        return 0;
    }
    for(j=L.length;j>=i-1;j--){
        L.Data[j+1]=L.Data[j];//结点依次后移
    }
    L.Data[i-1]=t; //插入t
    L.length++; //表长+1
    return 1;
}

main(){             //主程序
    SeqList L;
    Create(L);
    InsertList(L,99,2);
    Out(L);
}
  
```  


# 9月4号代码  
   - 实验课代码，实现第一章部分功能。  

```cpp  

#include <stdio.h> 
#include <string.h> 

//定义一个结构体
typedef struct student{
	//数字占一个字符，文字占两个字符，字符串最后还有结束符'\0' 占一位 
	char number[10];//学号
	char name[7];//名字
	char profession[11];//专业
	char sex[3]; //性别
	char tell[12];//电话
	char native[5];//籍贯 
}Stu;

//结构体内容 
Stu s[10]={//可以放十条信息，不够再加 
	{"201710001","张三","物联网","男","13812345678","贺州"},
	{"201710002","李蕾","物联网","女","15612345678","桂林"},
	{"201710003","赵磊磊","物联网","男","15812345678","南宁"},
	{"201710004","韩菲菲","物联网","女","17012345678","贺州"},	
};

//定义输出函数
 void Output (int n){
 	printf("%-10s%-7s%-11s%-5s%-12s%-5s\n","学号","姓名","专业","性别","电话","籍贯");
 	for(int i=0;i<n;i++){
	 	printf("%-10s%-7s%-11s%-5s%-12s%-5s\n",s[i].number,s[i].name,s[i].profession,s[i].sex,s[i].tell,s[i].native);
	 }
 };
 
 //添加
  int add (int n){
  	printf("请输入：学号，姓名，专业，性别，电话，籍贯\n");
  	gets(s[n].number);
  	gets(s[n].name);
  	gets(s[n].profession);
  	gets(s[n].sex);
  	gets(s[n].tell);
  	gets(s[n].native);
  	n=n+1;
  	return n;
  }
  
 //查找
 int find (int n) {
 	char name[7];
 	printf("请输入所要查找的学生姓名："); 
	scanf("%s",&name);//输入不要忘了加'&' 
 	for(int i=0;i<n;i++){
	 	if(strcmp(name,s[i].name)==0){//strcmp用于字符串比较，头文件 <string.h> ，字符串相等结果为0
		  //输出查找内容 
		  printf("%-10s%-7s%-11s%-5s%-12s%-5s\n","学号","姓名","专业","性别","电话","籍贯");
		  printf("%-10s%-7s%-11s%-5s%-12s%-5s\n",s[i].number,s[i].name,s[i].profession,s[i].sex,s[i].tell,s[i].native);
	 } 
	 printf("未搜索到该学生。\n");break;
 	};
 	return 0;
 }
 
 //删除
 int del (int n){
 	char name[7];
 	printf("请输入所要删除的学生姓名："); 
	scanf("%s",&name);
 	for(int i=0;i<n;i++){
	 	if(strcmp(name,s[i].name)==0){
		  //删除动作
		  
  		}
	 } 
	printf("未搜索到该学生。\n");break;
 	};
 	return 0;
 }
 
 //主函数 
 main (){
 	//int n; 
 	//add(4);
 	//find(5);
 	//del(5);
 	Output(5);
 } ;

```
